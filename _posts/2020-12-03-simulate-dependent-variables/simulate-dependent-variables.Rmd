---
title: "Simulate dependent variables"
description: |
  When you simulate a dataset it is often not enough to have correctly distributed independent variables, but you also want to have some dependency between the variables. In this post we explore ways of doing this.
author:
  - name: Richard Vogg
    url: https://github.com/richardvogg
date: 12-03-2020
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


### Packages

Most of the functions that we are using here are actually part of base R.

We will need some functions from the dplyr package and the ggplot2 package for quick visualizations, but these are optional.

```{r}
library(dplyr)
library(ggplot2)
```

## Simulating dependent variables

If we want to have a dataset that "makes sense" from a real world perspective, wouldn't it be great if managers in general had higher balances than analysts? Or if 18 years old clients are less likely to be married than 30 years olds?
This does not mean that no 18 years old can be married in our dataset, but if we look at the average, we would expect a difference between both groups.
In this section we are going to have a look at techniques to create dependence between variables.

### Rule based

We can use `ifelse()` and `case_when()` from the {dplyr} package to create new variables that depend on others.

```{r}
k <- 7
married <- sample(c("Y","N"),k,replace=T)

data <- data.frame(id=1:k,married)

data %>% mutate(
  age=ifelse(married=="Y",rnorm(k,45,10),rnorm(k,30,10)) %>% pmax(18) %>% round()
)

```

In this small example we will not see the effect, but when we simulate 1000 clients and take a look at their average age, we can see that there is a difference between the two groups.

```{r}
k <- 1000
married <- sample(c("Y","N"),k,replace=T)

data <- data.frame(id=1:k,married)

data %>% mutate(
  age=ifelse(married=="Y",rnorm(k,45,5),rnorm(k,30,10)) %>% 
    pmax(18) %>% 
    round()
    ) %>% 
  ggplot(aes(x=married,y=age))+geom_boxplot()
```

If you have more than two options, `case_when()` can help.

```{r}
k <- 1000

ocupation <- sample(c("analyst","manager","sr analyst"),k,replace=T,prob=c(10,2,3))

data <- data.frame(id=1:k,ocupation)

data <- data %>% mutate(balance=case_when(
  ocupation=="analyst" ~ 100+rexp(k,0.01),
  ocupation=="sr analyst" ~ 200+rexp(k,0.005),
  TRUE ~ 500+rexp(k,0.001) #this is the else case
))

#Check the average balance per group
data %>% 
  ggplot(aes(x=ocupation,y=balance))+geom_violin()
```


### Correlation based

If we just deal with numeric variables and want to have a slightly more complex connection between the different variables, we can also try this approach, for which we specify a correlation matrix beforehand and reorder our variables afterwards so that they match the desired correlation.

Of course, we need to find reasonable correlation values, for example between age and number of kids (slightly positively correlated) or between savings and number of kids (slightly negatively correlated).

```{r}
set.seed(64)

k <- 2000

age <- rnorm(k,mean=35,sd=10) %>% pmax(18) %>% round()
balance <- rexp(k,rate=0.001) %>% round(2)
tenure <- rnorm(k,mean=15,sd=5) %>% pmax(1) %>% round()
kids_cnt <- sample(0:5,k,replace=T,prob=c(100,120,80,30,5,1))


data <- data.frame(age,balance,kids_cnt,tenure)
data %>% head(7)
```

We directly see that there are things that don't make sense, like the 22-years-old with a tenure of 22 years.

To improve this, we want to reshuffle the rows and get a distribution close to a desired one. First we simulate a helping dataset of same size, where every entry is random normal distributed.

```{r}
nvars <- ncol(data)
numobs <- nrow(data)

set.seed(3)
rnorm_helper <- matrix(rnorm(nvars*numobs,0,1),nrow=nvars)

```

The correlation of this matrix should be close to the identity matrix.

```{r}
cor(t(rnorm_helper))
```

Next, we specify our desired correlation matrix:

```{r}
Q <- matrix(c(1,0.3,0.4,0.2,  0.3,1,0,0.3,  0.4,0,1,-0.3,  0.2,0.3,-0.3,1),ncol=nvars)

Q
```

We can now multiply the `rnorm_helper` matrix with the Cholesky decomposition of our desired correlation matrix `Q`. Why this works, is explained in the following comment. If you are not interested in mathematical details, you can skip this part.

![](img/Cholesky.png)

(Explanation found [here](https://math.stackexchange.com/q/163472))

```{r}
L <- t(chol(Q))
Z <- L %*% rnorm_helper
```

Good, now we convert this new data to a data frame and give it the name of our original data. The correlation of this dataset is close to our desired outcome.

```{r}
raw <- as.data.frame(t(Z),row.names=NULL,optional=FALSE)
names(raw) <- names(data)
head(raw,7,addrownums=FALSE)
cor(raw)
```

However, this dataset `raw` does not have anything to do with our original data. It is still our transformed random normal data. But as we know that this dataset has the correct correlation, we can use this to reorder the rows of our other dataset.

And then we just replace the largest value of the random normal dataset with the largest value in our dataset, the second largest with the second largest etc. We go column by column and repeat this procedure.

```{r}
for(name in names(raw)) {
  raw <- raw[order(raw[,name]),]
  data <- data[order(data[,name]),]
  raw[,name] <- data[,name]
}

```

Let's check the correlation of this new dataset. It is not exactly what we wished, but close enough. The reason for this is that our variables take less values than a random normal distributed variable (e.g. kids count just takes values between 0 and 5).

```{r}
cor(raw)
```


We can also take a look at the reshuffled dataset.

```{r}
head(raw,7,addrownums=FALSE)
```

